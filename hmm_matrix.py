import numpy as np

# Состояния
states = np.array(["S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "DEAD"])

# Матрица переходов P (строка — откуда, столбец — куда)

P = np.array([
    [0.25, 0.25, 0.0, 0.0, 0.25, 0.25, 0.0, 0.0, 0.0],  
    [0.0, 0.0, 0.25, 0.25, 0.0, 0.0, 0.25, 0.25, 0.0],  
    [0.0, 0.0, 0.25, 0.25, 0.0, 0.0, 0.25, 0.25, 0.0],
    [0.25, 0.25, 0.0, 0.0, 0.25, 0.25, 0.0, 0.0, 0.0], 
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], 
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],  
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
    [0.0, 0.0, 0.0, 0.0, 0.0 , 0.0, 0.0, 0.0, 1.0],
    [0.0, 0.0, 0.0, 0.0, 0.0 , 0.0, 0.0, 0.0, 1.0],
])
# Начальное распределение: на 100% в сумме у трех состояний где он выжил
pi = np.array([0.25, 0.25, 0.25, 0.25, 0, 0, 0, 0, 0]) 

if __name__ == "__main__":
    # print("Шаг 0:", pi, "=>", dict(zip(states, pi)))
    print("Шаг 0:", pi, np.sum(pi))
    
    # Делаем 10 шагов: pi_{t+1} = pi_t * P
    for t in range(1, 10):
        pi = pi @ P      # умножение вектора-строки на матрицу переходов
    #   print(f"Шаг {t}:", pi,'\n',  "=>", dict(zip(states, pi)))
        print(f"Шаг {t}:", pi, np.sum(pi))